Listar Variables Globales =>
git config --global -e
git config --global --list
git config --global -l

Salir De Vim Entrando Por Medio Del Commit =>
esc:wq(enter)

Re-Construir Todo El Proyecto Al Ultimo Commit =>
git checkout -- .

Re-Construir Un Archivo DEl Proyecto Al Ultimo Commit =>
git checkout -- <NombreArchivo>

Agrega Todos Los Archivos .txt De TODO El Proyecto =>
git add "*.txt"

Agrega Todos Los Archivos .txt En El Directorio Actual =>
git add *.txt

Agregar Todos Los Archivos =>
git add --all
git add -A

Agrega Los Archivos Que Listemos =>
git add <lista de archivos>

Agrega Todos Los PDFS Dentro La Carpeta Uploads =>
git add uploads/*.pdf

Agrega Todos Los Archivos Dentro De La Carpeta Uploads =>
git add uploads/

Retirar Un Archivos Del Staged =>
git reset HEAD(Ultimo Commit) <Nombre Archivo>

Retirar Los Cambios De Un Archivo =>
git checkout -- <Nombre Archivo>

Alias Para Extensos Comandos =>
git config --global alias.lg "log --oneline --decorate --all --graph"
Nuevo Comando => git lg
git config --global alias.s "status -s -b"
Nuevo Comando => git s
--------------------------------------------------

Mostrar Todas Las Modificaciones Entre El Ultimo Commit Y El Estado Actual
Del Archivo =>
git diff

Mostrar Todas Las Modificaciones Entre El Ultimo Commit Y El Estado Actual
Del Archivo Que Se Encuentre En El Staged =>
git diff --staged

Actualizar O Corregir Los Nombres De Los Commits =>
git commit --amend -m "Nuevo Nombre Commit"

Incluir Cambios Realizados En Los Archivos A Un Commit Ya Existente Para 
No Crear Un Nuevo Commit, Pero Se Debe Seleccionar El ID Del Commit Anterior
Al HEAD(Ultimo Commit) =>
git reset --soft <Id Del Commit>
Ahora Tengo La Oportunidad De Hacer Mas Cambios Y Se Incluyen Automaticamente
Para Subir Con Un Simple Commit

Quitar Del Staged Y De Los Logs Los Commits Que Esten Despues Del ID Ingresado
Pero No Se Eliminan Del Proyecto Ni Se Modifica El Archivo =>
git reset --mixed <ID Del Commit>

DESTRUIR Por Completo Los Cambios Del Staged Y De Los Logs, Los Commits
Que Esten Despues Del ID Ingresado, Pero No Se Eliminan Del Proyecto SI 
vienen Antes De Un --mixed, Pero SiNo Es Asì, Se Eliminan Los Archivos
Del Proyecto Con Sus Cambios En Dicho Archivo =>
git reset --hard <ID Del Commit>

Muestra Todo El Movimiento Realizados En Los Commits A travès Del Tiempo =>
git reflog

Tambien Me Ayuda A CONSTRUIR Todos Los Commits Hasta Donde Le Indique El 
ID =>
git reset --hard <ID Del Commit>

Renombrar Archivos Con Git(Es Importante Para Que GIT Lleve Un Seguimiento 
De Dicho Archivo) =>
git mv destruir.txt salvar.txt

Eliminar Archivos Con Git(Es Importante Para Que GIT Lleve Un Seguimiento 
De Dicho Archivo) =>
git rm salvar.txt

Sirve Para Actualizar Todo Los Archivos Del Proyecto Y Los Monta Al Staged
Para Que Git Les Haga Seguimiento, Especialmente Si No Lo Tenian Con 
Anterioridad =>
git add -u

RAMAS =>
Ver Todas Las Ramas =>
git branch 

Movernos A Una Rama =>
git checkout <NombreRama>

Crear Y Movernos A Una Rama Al Mismo Tiempo =>
git checkout -b <NombreRama>

Ver La Diferencia De Una Rama En Particular Con La Rama Master =>
(fast-foward)
git diff <ramaUno> <ramaMaster>

Eliminar una rama =>
git branch -d rama-villanos

MERGE (AUTOMATICOS SIN CONFLICTOS) =>
git merge <NombreRama>

MERGE (SOLUCION DE CONFLICTOS) => 
HEAD => Lo que tenemos en la rama donde estamos parados
y decidir de forma manual que es lo que queremos incorporar
que se ven debajo, que serian los cambios entrantes de los 
otros compañeros, el staged muestra lo siguiente en el archivo
con el conflicto solucionado UU.

TAGS -> Etiquetas =>
Son Una Referencia A Un Commit Especifico.

Crear Un Tag =>
git tag <NombreTag>
git tag -a v1.0.0 -m "Version Uno"

Ver Todos Los Tags =>
git tag

Tag Para Un Commit En Especifico =>
git tag -a v0.1.0 345d7de -m "Version Alfa" 

Eliminar Un Tag =>
git tag -d <NombreTag>

Mostrar Los Mensajes Y Detalles De Los Tags =>
git show <NombreTag>
-----------------------------------

STASH =>
Para Aplicar o Guardar Modificaciones Funcionales
Incompletas De Forma Temporal.

Crear Un Stash =>
git stash
git stash save

Mensajes Para Los stash =>
git stash save "AquiVaMensaje"

Listar Todos Los stash =>
git stash list
git stash list stash@{posicion}

Restaurar Los Cambios Guardados En El stash
Toma La Ultima Entrada Del stash Y Lo Restaura =>
git stash apply

Entrada O Posición Especifica =>
git stash apply stash@{0}

Restaurar Los Cambios Guardados En El stash,
pero Ademas Lo Elimina Directamente Del stash =>
git stash pop
git stash pop stash@{posicion}

Cuando Se Presenta Conflictos Se Soluciona Como Un
merge Normal Y Para Eliminar El stash De Los Logs 
Se Hace Lo siguiente:
Elimina La Primera Posición Del stash =>
git stash drop

Elimina Posición Especifica =>
git stash drop stash@{posicion}

Guarda Todo Menos Los Archivos Que
Esten En El Stage =>
git stash save --keep-index

Incluye Todos Los Archivos Incluso A Los
Que Git No Les Da Seguimiento =>
git stash save --include-untracked

Hace Que Aparezca Información Superficial 
De Cada Una De Las Entradas Del Stash =>
git stash list --stat

Hace Que Aparezca Información Detallada 
De La Ultima Entrada En El Stash =>
git show stash

Posición Especifica Del stash =>
git show stash@{posicion}

Borrar Todas Las Entradas En El stash =>
git stash clear
-----------------------------------------------------

REBASE =>
Se Utiliza para actualizar los commits de una rama
diferente a la master al mismo nivel y despues de 
tenerla al mismo nivel pone los Commits
que tenga esa rama diferente a la master, por encima
o en la cabeza. Luego hacemos un merge Hacia la rama
master para actualizarla al mismo nivel.
git rebase master

SQUASH(Rebase Interactivo) =>
Me sirve para unir o fusionar commits diferentes que
realmente se pueden hacer en uno solo.

git rebase -i HEAD~4

Muestra los commits de forma ASCendente,
del commit más lejos al HEAD al más cercano.

Funciona solo dos commits, donde se ponga el squash
y su commit superior, si pones otro squash adujunta 
uno mas, hace lo mismo y asi sucesivamente.

REWORD =>
Al seleccionar esta opcion solo me edita el mensaje del
commit al cual le ponga reword, no se edita en ese punto
se debe pasar a la otra pantalla y alli se actualiza el 
mensaje, especialmente cuando son nombres de commits muy
extensos.

EDIT(SEPARAR UN COMMIT EN DOS O MAS COMMITS POR SEPARADO) =>
Nos ayuda a separar los commits unidos en dos o mas.
git rebase -i HEAD~2

- Escribo la opcion edit.
- Luego hago un mixed, para sacar los archivos de los logs
  y del staged.
- Aplico un commit para cada uno.
- git reabse --continue(para finalizar el rebase).
-------------------------------------------------------------

GitHub =>
La direccion donde esta mi repositorio o proyecto remoto
git remote -v

tags =>
Los tags no suben por defecto a GitHub, pero hay un comando para
hacerlo.
git push --tags

push =>
Los cambios del repositorio local son enviados al repositorio remoto.
git push

"REALIZAR UN PULL O UN FETCH ES UNA EXCELENTE PRACTICA, ANTES DE HACER
UN PUSH"

pull =>
Trae los cambios del repositorio Remoto y ademas trata de hacer un
merge Automaticamente con nuestro repositorio local.
git pull

fetch =>
Trae los cambios del repositorio Remoto y PERO NO trata de hacer un
merge Automaticamente con nuestro repositorio local, Solo muestra
los cambios realizados y nos recomienda hacer un push o pull.
git fetch